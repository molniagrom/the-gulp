const xpath = require('./xpath.js');
const dom = require('xmldom').DOMParser;
const assert = require('assert');

var xhtmlNs = 'http://www.w3.org/1999/xhtml';

describe('xpath', () => {
    describe('api', () => {
        it('should contain the correct methods', () => {
            assert.ok(xpath.evaluate, 'evaluate api ok.');
            assert.ok(xpath.select, 'select api ok.');
            assert.ok(xpath.parse, 'parse api ok.');
        });

        it('should support .evaluate()', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);
            var nodes = xpath.evaluate('//title', doc, null, xpath.XPathResult.ANY_TYPE, null).nodes;

            assert.strictEqual('title', nodes[0].localName);
            assert.strictEqual('Harry Potter', nodes[0].firstChild.data);
            assert.strictEqual('<title>Harry Potter</title>', nodes[0].toString());
        });

        it('should support .select()', () => {
            var xml = '<?book title="Harry Potter"?><?series title="Harry Potter"?><?series books="7"?><book><!-- This is a great book --><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);
            var nodes = xpath.select('//title', doc);
            assert.strictEqual('title', nodes[0].localName);
            assert.strictEqual('Harry Potter', nodes[0].firstChild.data);
            assert.strictEqual('<title>Harry Potter</title>', nodes[0].toString());

            var nodes2 = xpath.select('//node()', doc);
            assert.strictEqual(7, nodes2.length);

            var pis = xpath.select("/processing-instruction('series')", doc);
            assert.strictEqual(2, pis.length);
            assert.strictEqual('books="7"', pis[1].data);
        });
    });

    describe('parsing', () => {
        it('should detect unterminated string literals', () => {
            function testUnterminated(path) {
                assert.throws(function () {
                    xpath.evaluate('"hello');
                }, function (err) {
                    return err.message.indexOf('Unterminated') !== -1;
                });
            }

            testUnterminated('"Hello');
            testUnterminated("'Hello");
            testUnterminated('self::text() = "\""');
            testUnterminated('"\""');
        });
    });

    describe('.select()', () => {
        it('should select single nodes', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);

            assert.strictEqual('title', xpath.select('//title[1]', doc)[0].localName);
        });

        it('should select text nodes', () => {
            var xml = '<book><title>Harry</title><title>Potter</title></book>';
            var doc = new dom().parseFromString(xml);

            assert.deepEqual('book', xpath.select('local-name(/book)', doc));
            assert.deepEqual('Harry,Potter', xpath.select('//title/text()', doc).toString());
        });

        it('should select number values', () => {
            var xml = '<book><title>Harry</title><title>Potter</title></book>';
            var doc = new dom().parseFromString(xml);

            assert.deepEqual(2, xpath.select('count(//title)', doc));
        });

        it('should select with namespaces', () => {
            var xml = '<book><title xmlns="myns">Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);

            var nodes = xpath.select('//*[local-name(.)="title" and namespace-uri(.)="myns"]', doc);
            assert.strictEqual('title', nodes[0].localName);
            assert.strictEqual('myns', nodes[0].namespaceURI);

            var nodes2 = xpath.select('/*/title', doc);

            assert.strictEqual(0, nodes2.length);
        });

        it('should select with namespaces, using a resolver', () => {
            var xml = '<book xmlns:testns="http://example.com/test" xmlns:otherns="http://example.com/other"><otherns:title>Narnia</otherns:title><testns:title>Harry Potter</testns:title><testns:field testns:type="author">JKR</testns:field></book>';
            var doc = new dom().parseFromString(xml);

            var resolver = {
                mappings: {
                    'testns': 'http://example.com/test'
                },
                lookupNamespaceURI: function (prefix) {
                    return this.mappings[prefix];
                }
            };

            var nodes = xpath.selectWithResolver('//testns:title/text()', doc, resolver);
            assert.strictEqual('Harry Potter', nodes[0].nodeValue);

            assert.strictEqual('JKR', xpath.selectWithResolver('//testns:field[@testns:type="author"]/text()', doc, resolver)[0].nodeValue);

            var nodes2 = xpath.selectWithResolver('/*/testns:*', doc, resolver);

            assert.strictEqual(2, nodes2.length);
        });

        it('should select from xml with a default namespace, using a resolver', () => {
            var xml = '<book xmlns="http://example.com/test"><title>Harry Potter</title><field type="author">JKR</field></book>';
            var doc = new dom().parseFromString(xml);

            var resolver = {
                mappings: {
                    'testns': 'http://example.com/test'
                },
                lookupNamespaceURI: function (prefix) {
                    return this.mappings[prefix];
                }
            }

            var nodes = xpath.selectWithResolver('//testns:title/text()', doc, resolver);
            assert.strictEqual('Harry Potter', xpath.selectWithResolver('//testns:title/text()', doc, resolver)[0].nodeValue);
            assert.strictEqual('JKR', xpath.selectWithResolver('//testns:field[@type="author"]/text()', doc, resolver)[0].nodeValue);
        });

        it('should select with namespaces, prefixes different in xml and xpath, using a resolver', () => {
            var xml = '<book xmlns:testns="http://example.com/test"><testns:title>Harry Potter</testns:title><testns:field testns:type="author">JKR</testns:field></book>';
            var doc = new dom().parseFromString(xml);

            var resolver = {
                mappings: {
                    'ns': 'http://example.com/test'
                },
                lookupNamespaceURI: function (prefix) {
                    return this.mappings[prefix];
                }
            }

            var nodes = xpath.selectWithResolver('//ns:title/text()', doc, resolver);
            assert.strictEqual('Harry Potter', nodes[0].nodeValue);

            assert.strictEqual('JKR', xpath.selectWithResolver('//ns:field[@ns:type="author"]/text()', doc, resolver)[0].nodeValue);
        });

        it('should select with namespaces, using namespace mappings', () => {
            var xml = '<book xmlns:testns="http://example.com/test"><testns:title>Harry Potter</testns:title><testns:field testns:type="author">JKR</testns:field></book>';
            var doc = new dom().parseFromString(xml);
            var select = xpath.useNamespaces({ 'testns': 'http://example.com/test' });

            assert.strictEqual('Harry Potter', select('//testns:title/text()', doc)[0].nodeValue);
            assert.strictEqual('JKR', select('//testns:field[@testns:type="author"]/text()', doc)[0].nodeValue);
        });

        it('should select attributes', () => {
            var xml = '<author name="J. K. Rowling"></author>';
            var doc = new dom().parseFromString(xml);

            var author = xpath.select1('/author/@name', doc).value;
            assert.strictEqual('J. K. Rowling', author);
        });
    });

    describe('selection', () => {
        it('should select with multiple predicates', () => {
            var xml = '<characters><character name="Snape" sex="M" age="50" /><character name="McGonnagal" sex="F" age="65" /><character name="Harry" sex="M" age="14" /></characters>';
            var doc = new dom().parseFromString(xml);

            var characters = xpath.select('/*/character[@sex = "M"][@age > 40]/@name', doc);

            assert.strictEqual(1, characters.length);
            assert.strictEqual('Snape', characters[0].textContent);
        });

        // https://github.com/goto100/xpath/issues/37
        it('should select multiple attributes', () => {
            var xml = '<authors><author name="J. K. Rowling" /><author name="Saeed Akl" /></authors>';
            var doc = new dom().parseFromString(xml);

            var authors = xpath.select('/authors/author/@name', doc);
            assert.strictEqual(2, authors.length);
            assert.strictEqual('J. K. Rowling', authors[0].value);

            // https://github.com/goto100/xpath/issues/41
            doc = new dom().parseFromString('<chapters><chapter v="1"/><chapter v="2"/><chapter v="3"/></chapters>');
            var nodes = xpath.select("/chapters/chapter/@v", doc);
            var values = nodes.map(function (n) { return n.value; });

            assert.strictEqual(3, values.length);
            assert.strictEqual("1", values[0]);
            assert.strictEqual("2", values[1]);
            assert.strictEqual("3", values[2]);
        });

        it('should compare string values of numbers with numbers', () => {
            assert.ok(xpath.select1('"000" = 0'), '000');
            assert.ok(xpath.select1('"45.0" = 45'), '45');
        });

        it('should correctly compare strings with booleans', () => {
            // string should downcast to boolean
            assert.strictEqual(false, xpath.select1('"false" = false()'), '"false" = false()');
            assert.strictEqual(true, xpath.select1('"a" = true()'), '"a" = true()');
            assert.strictEqual(true, xpath.select1('"" = false()'), '"" = false()');
        });

        it('should evaluate local-name() and name() on processing instructions', () => {
            var xml = '<?book-record added="2015-01-16" author="J.K. Rowling" ?><book>Harry Potter</book>';
            var doc = new dom().parseFromString(xml);
            var expectedName = 'book-record';
            var localName = xpath.select('local-name(/processing-instruction())', doc);
            var name = xpath.select('name(/processing-instruction())', doc);

            assert.deepEqual(expectedName, localName, 'local-name() - "' + expectedName + '" !== "' + localName + '"');
            assert.deepEqual(expectedName, name, 'name() - "' + expectedName + '" !== "' + name + '"');
        });

        it('should support substring-after()', () => {
            var xml = '<classmate>Hermione</classmate>';
            var doc = new dom().parseFromString(xml);

            var part = xpath.select('substring-after(/classmate, "Her")', doc);
            assert.deepEqual('mione', part);
        });

        it('should support preceding:: on document fragments', () => {
            var doc = new dom().parseFromString('<n />'),
                df = doc.createDocumentFragment(),
                root = doc.createElement('book');

            df.appendChild(root);

            for (var i = 0; i < 10; i += 1) {
                root.appendChild(doc.createElement('chapter'));
            }

            var chapter = xpath.select1("book/chapter[5]", df);

            assert.ok(chapter, 'chapter');

            assert.strictEqual(xpath.select("count(preceding::chapter)", chapter), 4);
        });

        it('should allow getting sorted and unsorted arrays from nodesets', () => {
            const doc = new dom().parseFromString('<book><character>Harry</character><character>Ron</character><character>Hermione</character></book>');
            const path = xpath.parse("/*/*[3] | /*/*[2] | /*/*[1]");
            const nset = path.evaluateNodeSet({ node: doc });
            const sorted = nset.toArray();
            const unsorted = nset.toUnsortedArray();

            assert.strictEqual(sorted.length, 3);
            assert.strictEqual(unsorted.length, 3);

            assert.strictEqual(sorted[0].textContent, 'Harry');
            assert.strictEqual(sorted[1].textContent, 'Ron');
            assert.strictEqual(sorted[2].textContent, 'Hermione');

            assert.notEqual(sorted[0], unsorted[0], "first nodeset element equal");
        });

        it('should compare nodesets to nodesets (=)', () => {
            var xml = '<school><houses>' +
                '<house name="Gryffindor"><student>Harry</student><student>Hermione</student></house>' +
                '<house name="Slytherin"><student>Draco</student><student>Crabbe</student></house>' +
                '<house name="Ravenclaw"><student>Luna</student><student>Cho</student></house>' +
                '</houses>' +
                '<honorStudents><student>Hermione</student><student>Luna</student></honorStudents></school>';

            var doc = new dom().parseFromString(xml);
            var houses = xpath.parse('/school/houses/house[student = /school/honorStudents/student]').select({ node: doc });

            assert.strictEqual(houses.length, 2);

            var houseNames = houses.map(function (node) { return node.getAttribute('name'); }).sort();

            assert.strictEqual(houseNames[0], 'Gryffindor');
            assert.strictEqual(houseNames[1], 'Ravenclaw');
        });

        it('should compare nodesets to nodesets (>=)', () => {
            var xml = '<school><houses>' +
                '<house name="Gryffindor"><student level="5">Harry</student><student level="9">Hermione</student></house>' +
                '<house name="Slytherin"><student level="1">Goyle</student><student level="1">Crabbe</student></house>' +
                '<house name="Ravenclaw"><student level="4">Luna</student><student level="3">Cho</student></house>' +
                '</houses>' +
                '<courses><course minLevel="9">DADA</course><course minLevel="4">Charms</course></courses>' +
                '</school>';

            var doc = new dom().parseFromString(xml);
            var houses = xpath.parse('/school/houses/house[student/@level >= /school/courses/course/@minLevel]').select({ node: doc });

            assert.strictEqual(houses.length, 2);

            var houseNames = houses.map(function (node) { return node.getAttribute('name'); }).sort();

            assert.strictEqual(houseNames[0], 'Gryffindor');
            assert.strictEqual(houseNames[1], 'Ravenclaw');
        });

        it('should support various inequality expressions on nodesets', () => {
            var xml = "<books><book num='1' title='PS' /><book num='2' title='CoS' /><book num='3' title='PoA' /><book num='4' title='GoF' /><book num='5' title='OotP' /><book num='6' title='HBP' /><book num='7' title='DH' /></books>";
            var doc = new dom().parseFromString(xml);

            var options = { node: doc, variables: { theNumber: 3, theString: '3', theBoolean: true } };

            var numberPaths = [
                '/books/book[$theNumber <= @num]',
                '/books/book[$theNumber < @num]',
                '/books/book[$theNumber >= @num]',
                '/books/book[$theNumber > @num]'
            ];

            var stringPaths = [
                '/books/book[$theString <= @num]',
                '/books/book[$theString < @num]',
                '/books/book[$theString >= @num]',
                '/books/book[$theString > @num]'
            ];

            var booleanPaths = [
                '/books/book[$theBoolean <= @num]',
                '/books/book[$theBoolean < @num]',
                '/books/book[$theBoolean >= @num]',
                '/books/book[$theBoolean > @num]'
            ];

            var lhsPaths = [
                '/books/book[@num <= $theNumber]',
                '/books/book[@num < $theNumber]'
            ];

            function countNodes(paths) {
                return paths
                    .map(xpath.parse)
                    .map(function (path) { return path.select(options) })
                    .map(function (arr) { return arr.length; });
            }

            assert.deepEqual(countNodes(numberPaths), [5, 4, 3, 2], 'numbers');
            assert.deepEqual(countNodes(stringPaths), [5, 4, 3, 2], 'strings');
            assert.deepEqual(countNodes(booleanPaths), [7, 6, 1, 0], 'numbers');
            assert.deepEqual(countNodes(lhsPaths), [3, 2], 'lhs');
        });

        it('should correctly evaluate context position', () => {
            var doc = new dom().parseFromString("<books><book><chapter>The boy who lived</chapter><chapter>The vanishing glass</chapter></book><book><chapter>The worst birthday</chapter><chapter>Dobby's warning</chapter><chapter>The burrow</chapter></book></books>");

            var chapters = xpath.parse('/books/book/chapter[2]').select({ node: doc });

            assert.strictEqual(2, chapters.length);
            assert.strictEqual('The vanishing glass', chapters[0].textContent);
            assert.strictEqual("Dobby's warning", chapters[1].textContent);

            var lastChapters = xpath.parse('/books/book/chapter[last()]').select({ node: doc });

            assert.strictEqual(2, lastChapters.length);
            assert.strictEqual('The vanishing glass', lastChapters[0].textContent);
            assert.strictEqual("The burrow", lastChapters[1].textContent);

            var secondChapter = xpath.parse('(/books/book/chapter)[2]').select({ node: doc });

            assert.strictEqual(1, secondChapter.length);
            assert.strictEqual('The vanishing glass', chapters[0].textContent);

            var lastChapter = xpath.parse('(/books/book/chapter)[last()]').select({ node: doc });

            assert.strictEqual(1, lastChapter.length);
            assert.strictEqual("The burrow", lastChapter[0].textContent);
        });
    });

    describe('string()', () => {
        it('should work with no arguments', () => {
            var doc = new dom().parseFromString('<book>Harry Potter</book>');

            var rootElement = xpath.select1('/book', doc);
            assert.ok(rootElement, 'rootElement is null');

            assert.strictEqual('Harry Potter', xpath.select1('string()', doc));
        });

        it('should work on document fragments', () => {
            var doc = new dom().parseFromString('<n />');
            var docFragment = doc.createDocumentFragment();

            var el = doc.createElement("book");
            docFragment.appendChild(el);

            var testValue = "Harry Potter";

            el.appendChild(doc.createTextNode(testValue));

            assert.strictEqual(testValue, xpath.select1("string()", docFragment));
        });

        it('should work correctly on boolean values', () => {
            assert.strictEqual('string', typeof xpath.select1('string(true())'));
            assert.strictEqual('string', typeof xpath.select1('string(false())'));
            assert.strictEqual('string', typeof xpath.select1('string(1 = 2)'));
            assert.ok(xpath.select1('"true" = string(true())'), '"true" = string(true())');
        });

        it('should work correctly on numbers', () => {
            assert.strictEqual('string', typeof xpath.select1('string(45)'));
            assert.ok(xpath.select1('"45" = string(45)'), '"45" = string(45)');
        });
    });

    describe('type conversion', () => {
        it('should convert strings to numbers correctly', () => {
            assert.strictEqual(45.2, xpath.select1('number("45.200")'));
            assert.strictEqual(55.0, xpath.select1('number("000055")'));
            assert.strictEqual(65.0, xpath.select1('number("  65  ")'));

            assert.strictEqual(true, xpath.select1('"" != 0'), '"" != 0');
            assert.strictEqual(false, xpath.select1('"" = 0'), '"" = 0');
            assert.strictEqual(false, xpath.select1('0 = ""'), '0 = ""');
            assert.strictEqual(false, xpath.select1('0 = "   "'), '0 = "   "');

            assert.ok(Number.isNaN(xpath.select('number("")')), 'number("")');
            assert.ok(Number.isNaN(xpath.select('number("45.8g")')), 'number("45.8g")');
            assert.ok(Number.isNaN(xpath.select('number("2e9")')), 'number("2e9")');
            assert.ok(Number.isNaN(xpath.select('number("+33")')), 'number("+33")');
        });

        it('should convert numbers to strings correctly', () => {
            assert.strictEqual('0.0000000000000000000000005250000000000001', xpath.parse('0.525 div 1000000 div 1000000 div 1000000 div 1000000').evaluateString());
            assert.strictEqual('525000000000000000000000', xpath.parse('0.525 * 1000000 * 1000000 * 1000000 * 1000000').evaluateString());
        });

        it('should provide correct string value for cdata sections', () => {
            const xml = "<people><person><![CDATA[Harry Potter]]></person><person>Ron <![CDATA[Weasley]]></person></people>";
            const doc = new dom().parseFromString(xml);

            const person1 = xpath.parse("/people/person").evaluateString({ node: doc });
            const person2 = xpath.parse("/people/person/text()").evaluateString({ node: doc });
            const person3 = xpath.select("string(/people/person/text())", doc);
            const person4 = xpath.parse("/people/person[2]").evaluateString({ node: doc });

            assert.strictEqual(person1, 'Harry Potter');
            assert.strictEqual(person2, 'Harry Potter');
            assert.strictEqual(person3, 'Harry Potter');
            assert.strictEqual(person4, 'Ron Weasley');
        });

        it('should convert various node types to string values', () => {
            var xml = "<book xmlns:hp='http://harry'><!-- This describes the Harry Potter Book --><?author name='J.K. Rowling' ?><title lang='en'><![CDATA[Harry Potter & the Philosopher's Stone]]></title><character>Harry Potter</character></book>",
                doc = new dom().parseFromString(xml),
                allText = xpath.parse('.').evaluateString({ node: doc }),
                ns = xpath.parse('*/namespace::*[name() = "hp"]').evaluateString({ node: doc }),
                title = xpath.parse('*/title').evaluateString({ node: doc }),
                child = xpath.parse('*/*').evaluateString({ node: doc }),
                titleLang = xpath.parse('*/*/@lang').evaluateString({ node: doc }),
                pi = xpath.parse('*/processing-instruction()').evaluateString({ node: doc }),
                comment = xpath.parse('*/comment()').evaluateString({ node: doc });

            assert.strictEqual(allText, "Harry Potter & the Philosopher's StoneHarry Potter");
            assert.strictEqual(ns, 'http://harry');
            assert.strictEqual(title, "Harry Potter & the Philosopher's Stone");
            assert.strictEqual(child, "Harry Potter & the Philosopher's Stone");
            assert.strictEqual(titleLang, 'en');
            assert.strictEqual(pi.trim(), "name='J.K. Rowling'");
            assert.strictEqual(comment, ' This describes the Harry Potter Book ');
        });

        it('should convert booleans to numbers correctly', () => {
            var num = xpath.parse('"a" = "b"').evaluateNumber();

            assert.strictEqual(num, 0);

            var str = xpath.select('substring("expelliarmus", 1, "a" = "a")');

            assert.strictEqual(str, 'e');
        });
    });

    describe('parsed expressions', () => {
        it('should work with no options', () => {
            var parsed = xpath.parse('5 + 7');

            assert.strictEqual(typeof parsed, "object", "parse() should return an object");
            assert.strictEqual(typeof parsed.evaluate, "function", "parsed.evaluate should be a function");
            assert.strictEqual(typeof parsed.evaluateNumber, "function", "parsed.evaluateNumber should be a function");

            assert.strictEqual(parsed.evaluateNumber(), 12);

            // evaluating twice should yield the same result
            assert.strictEqual(parsed.evaluateNumber(), 12);
        });

        it('should support select1()', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);
            var parsed = xpath.parse('/*/title');

            assert.strictEqual(typeof parsed, 'object', 'parse() should return an object');

            assert.strictEqual(typeof parsed.select1, 'function', 'parsed.select1 should be a function');

            var single = parsed.select1({ node: doc });

            assert.strictEqual('title', single.localName);
            assert.strictEqual('Harry Potter', single.firstChild.data);
            assert.strictEqual('<title>Harry Potter</title>', single.toString());
        });

        it('should support select()', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);
            var parsed = xpath.parse('/*/title');

            assert.strictEqual(typeof parsed, 'object', 'parse() should return an object');

            assert.strictEqual(typeof parsed.select, 'function', 'parsed.select should be a function');

            var nodes = parsed.select({ node: doc });

            assert.ok(nodes, 'parsed.select() should return a value');
            assert.strictEqual(1, nodes.length);
            assert.strictEqual('title', nodes[0].localName);
            assert.strictEqual('Harry Potter', nodes[0].firstChild.data);
            assert.strictEqual('<title>Harry Potter</title>', nodes[0].toString());
        });

        it('should support .evaluateString() and .evaluateNumber()', () => {
            var xml = '<book><title>Harry Potter</title><numVolumes>7</numVolumes></book>';
            var doc = new dom().parseFromString(xml);
            var parsed = xpath.parse('/*/numVolumes');

            assert.strictEqual(typeof parsed, 'object', 'parse() should return an object');

            assert.strictEqual(typeof parsed.evaluateString, 'function', 'parsed.evaluateString should be a function');
            assert.strictEqual('7', parsed.evaluateString({ node: doc }));

            assert.strictEqual(typeof parsed.evaluateBoolean, 'function', 'parsed.evaluateBoolean should be a function');
            assert.strictEqual(true, parsed.evaluateBoolean({ node: doc }));

            assert.strictEqual(typeof parsed.evaluateNumber, 'function', 'parsed.evaluateNumber should be a function');
            assert.strictEqual(7, parsed.evaluateNumber({ node: doc }));
        });

        it('should support .evaluateBoolean()', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);
            var context = { node: doc };

            function evaluate(path) {
                return xpath.parse(path).evaluateBoolean(context);
            }

            assert.strictEqual(false, evaluate('/*/myrtle'), 'boolean value of empty node set should be false');

            assert.strictEqual(true, evaluate('not(/*/myrtle)'), 'not() of empty nodeset should be true');

            assert.strictEqual(true, evaluate('/*/title'), 'boolean value of non-empty nodeset should be true');

            assert.strictEqual(true, evaluate('/*/title = "Harry Potter"'), 'title equals Harry Potter');

            assert.strictEqual(false, evaluate('/*/title != "Harry Potter"'), 'title != Harry Potter should be false');

            assert.strictEqual(false, evaluate('/*/title = "Percy Jackson"'), 'title should not equal Percy Jackson');
        });

        it('should support namespaces', () => {
            var xml = '<characters xmlns:ps="http://philosophers-stone.com" xmlns:cs="http://chamber-secrets.com">' +
                '<ps:character>Quirrell</ps:character><ps:character>Fluffy</ps:character>' +
                '<cs:character>Myrtle</cs:character><cs:character>Tom Riddle</cs:character>' +
                '</characters>';
            var doc = new dom().parseFromString(xml);

            var expr = xpath.parse('/characters/c:character');
            var countExpr = xpath.parse('count(/characters/c:character)');
            var csns = 'http://chamber-secrets.com';

            function resolve(prefix) {
                if (prefix === 'c') {
                    return csns;
                }
            }

            function testContext(context, description) {
                try {
                    var value = expr.evaluateString(context);
                    var count = countExpr.evaluateNumber(context);

                    assert.strictEqual('Myrtle', value, description + ' - string value - ' + value);
                    assert.strictEqual(2, count, description + ' map - count - ' + count);
                } catch (e) {
                    e.message = description + ': ' + (e.message || '');
                    throw e;
                }
            }

            testContext({
                node: doc,
                namespaces: {
                    c: csns
                }
            }, 'Namespace map');

            testContext({
                node: doc,
                namespaces: resolve
            }, 'Namespace function');

            testContext({
                node: doc,
                namespaces: {
                    getNamespace: resolve
                }
            }, 'Namespace object');
        });

        it('should support custom functions', () => {
            var xml = '<book><title>Harry Potter</title></book>';
            var doc = new dom().parseFromString(xml);

            var parsed = xpath.parse('concat(double(/*/title),